// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: internal/proto/realogy/v1/mls_display_rules.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MlsDisplayRulesServiceClient is the client API for MlsDisplayRulesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MlsDisplayRulesServiceClient interface {
	// Get all the mls display rules for Active MLS. Pagination is supported through offset and limit parameters.
	GetMlsDisplayRules(ctx context.Context, in *GetMlsDisplayRulesByRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesByResponse, error)
	// Get all the mls display rules for both Active and InActive MLS. Pagination is supported through offset and limit parameters.
	GetMlsDisplayRulesIgnoreStatus(ctx context.Context, in *GetMlsDisplayRulesByRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesByResponse, error)
	// Get Mls Display Rules for a given mls source.
	GetMlsDisplayRulesBySource(ctx context.Context, in *GetMlsDisplayRulesBySourceRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesBySourceResponse, error)
	// Get Mls Display Rules for a given mls source, ignoring active or inactive status.
	GetMlsDisplayRulesBySourceIgnoreStatus(ctx context.Context, in *GetMlsDisplayRulesBySourceRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesBySourceResponse, error)
	UpdateMlsDisplayRulesStatus(ctx context.Context, in *UpdateMlsDisplayRulesStatusRequest, opts ...grpc.CallOption) (*UpdateMlsDisplayRulesStatusResponse, error)
	// Update MLS Display Rules for given source
	UpdateMlsDisplayRulesData(ctx context.Context, in *UpdateMlsDisplayRulesDataRequest, opts ...grpc.CallOption) (*UpdateMlsDisplayRulesDataResponse, error)
	// Stream mls display rules
	StreamMlsDisplayRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (MlsDisplayRulesService_StreamMlsDisplayRulesClient, error)
	// Stream mls display rules events.
	StreamMlsDisplayRulesEvent(ctx context.Context, in *StreamMlsDisplayRulesEventRequest, opts ...grpc.CallOption) (MlsDisplayRulesService_StreamMlsDisplayRulesEventClient, error)
	// Health Check MLS Display Rules API.
	HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthReply, error)
}

type mlsDisplayRulesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMlsDisplayRulesServiceClient(cc grpc.ClientConnInterface) MlsDisplayRulesServiceClient {
	return &mlsDisplayRulesServiceClient{cc}
}

func (c *mlsDisplayRulesServiceClient) GetMlsDisplayRules(ctx context.Context, in *GetMlsDisplayRulesByRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesByResponse, error) {
	out := new(GetMlsDisplayRulesByResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) GetMlsDisplayRulesIgnoreStatus(ctx context.Context, in *GetMlsDisplayRulesByRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesByResponse, error) {
	out := new(GetMlsDisplayRulesByResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesIgnoreStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) GetMlsDisplayRulesBySource(ctx context.Context, in *GetMlsDisplayRulesBySourceRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesBySourceResponse, error) {
	out := new(GetMlsDisplayRulesBySourceResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesBySource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) GetMlsDisplayRulesBySourceIgnoreStatus(ctx context.Context, in *GetMlsDisplayRulesBySourceRequest, opts ...grpc.CallOption) (*GetMlsDisplayRulesBySourceResponse, error) {
	out := new(GetMlsDisplayRulesBySourceResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesBySourceIgnoreStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) UpdateMlsDisplayRulesStatus(ctx context.Context, in *UpdateMlsDisplayRulesStatusRequest, opts ...grpc.CallOption) (*UpdateMlsDisplayRulesStatusResponse, error) {
	out := new(UpdateMlsDisplayRulesStatusResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/UpdateMlsDisplayRulesStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) UpdateMlsDisplayRulesData(ctx context.Context, in *UpdateMlsDisplayRulesDataRequest, opts ...grpc.CallOption) (*UpdateMlsDisplayRulesDataResponse, error) {
	out := new(UpdateMlsDisplayRulesDataResponse)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/UpdateMlsDisplayRulesData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mlsDisplayRulesServiceClient) StreamMlsDisplayRules(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (MlsDisplayRulesService_StreamMlsDisplayRulesClient, error) {
	stream, err := c.cc.NewStream(ctx, &MlsDisplayRulesService_ServiceDesc.Streams[0], "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/StreamMlsDisplayRules", opts...)
	if err != nil {
		return nil, err
	}
	x := &mlsDisplayRulesServiceStreamMlsDisplayRulesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MlsDisplayRulesService_StreamMlsDisplayRulesClient interface {
	Recv() (*MlsDisplayRules, error)
	grpc.ClientStream
}

type mlsDisplayRulesServiceStreamMlsDisplayRulesClient struct {
	grpc.ClientStream
}

func (x *mlsDisplayRulesServiceStreamMlsDisplayRulesClient) Recv() (*MlsDisplayRules, error) {
	m := new(MlsDisplayRules)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mlsDisplayRulesServiceClient) StreamMlsDisplayRulesEvent(ctx context.Context, in *StreamMlsDisplayRulesEventRequest, opts ...grpc.CallOption) (MlsDisplayRulesService_StreamMlsDisplayRulesEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &MlsDisplayRulesService_ServiceDesc.Streams[1], "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/StreamMlsDisplayRulesEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &mlsDisplayRulesServiceStreamMlsDisplayRulesEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MlsDisplayRulesService_StreamMlsDisplayRulesEventClient interface {
	Recv() (*StreamMlsDisplayRulesEventResponse, error)
	grpc.ClientStream
}

type mlsDisplayRulesServiceStreamMlsDisplayRulesEventClient struct {
	grpc.ClientStream
}

func (x *mlsDisplayRulesServiceStreamMlsDisplayRulesEventClient) Recv() (*StreamMlsDisplayRulesEventResponse, error) {
	m := new(StreamMlsDisplayRulesEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mlsDisplayRulesServiceClient) HealthCheck(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthReply, error) {
	out := new(HealthReply)
	err := c.cc.Invoke(ctx, "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/HealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MlsDisplayRulesServiceServer is the server API for MlsDisplayRulesService service.
// All implementations must embed UnimplementedMlsDisplayRulesServiceServer
// for forward compatibility
type MlsDisplayRulesServiceServer interface {
	// Get all the mls display rules for Active MLS. Pagination is supported through offset and limit parameters.
	GetMlsDisplayRules(context.Context, *GetMlsDisplayRulesByRequest) (*GetMlsDisplayRulesByResponse, error)
	// Get all the mls display rules for both Active and InActive MLS. Pagination is supported through offset and limit parameters.
	GetMlsDisplayRulesIgnoreStatus(context.Context, *GetMlsDisplayRulesByRequest) (*GetMlsDisplayRulesByResponse, error)
	// Get Mls Display Rules for a given mls source.
	GetMlsDisplayRulesBySource(context.Context, *GetMlsDisplayRulesBySourceRequest) (*GetMlsDisplayRulesBySourceResponse, error)
	// Get Mls Display Rules for a given mls source, ignoring active or inactive status.
	GetMlsDisplayRulesBySourceIgnoreStatus(context.Context, *GetMlsDisplayRulesBySourceRequest) (*GetMlsDisplayRulesBySourceResponse, error)
	UpdateMlsDisplayRulesStatus(context.Context, *UpdateMlsDisplayRulesStatusRequest) (*UpdateMlsDisplayRulesStatusResponse, error)
	// Update MLS Display Rules for given source
	UpdateMlsDisplayRulesData(context.Context, *UpdateMlsDisplayRulesDataRequest) (*UpdateMlsDisplayRulesDataResponse, error)
	// Stream mls display rules
	StreamMlsDisplayRules(*emptypb.Empty, MlsDisplayRulesService_StreamMlsDisplayRulesServer) error
	// Stream mls display rules events.
	StreamMlsDisplayRulesEvent(*StreamMlsDisplayRulesEventRequest, MlsDisplayRulesService_StreamMlsDisplayRulesEventServer) error
	// Health Check MLS Display Rules API.
	HealthCheck(context.Context, *HealthRequest) (*HealthReply, error)
	mustEmbedUnimplementedMlsDisplayRulesServiceServer()
}

// UnimplementedMlsDisplayRulesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMlsDisplayRulesServiceServer struct {
}

func (UnimplementedMlsDisplayRulesServiceServer) GetMlsDisplayRules(context.Context, *GetMlsDisplayRulesByRequest) (*GetMlsDisplayRulesByResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMlsDisplayRules not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) GetMlsDisplayRulesIgnoreStatus(context.Context, *GetMlsDisplayRulesByRequest) (*GetMlsDisplayRulesByResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMlsDisplayRulesIgnoreStatus not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) GetMlsDisplayRulesBySource(context.Context, *GetMlsDisplayRulesBySourceRequest) (*GetMlsDisplayRulesBySourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMlsDisplayRulesBySource not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) GetMlsDisplayRulesBySourceIgnoreStatus(context.Context, *GetMlsDisplayRulesBySourceRequest) (*GetMlsDisplayRulesBySourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMlsDisplayRulesBySourceIgnoreStatus not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) UpdateMlsDisplayRulesStatus(context.Context, *UpdateMlsDisplayRulesStatusRequest) (*UpdateMlsDisplayRulesStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMlsDisplayRulesStatus not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) UpdateMlsDisplayRulesData(context.Context, *UpdateMlsDisplayRulesDataRequest) (*UpdateMlsDisplayRulesDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMlsDisplayRulesData not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) StreamMlsDisplayRules(*emptypb.Empty, MlsDisplayRulesService_StreamMlsDisplayRulesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMlsDisplayRules not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) StreamMlsDisplayRulesEvent(*StreamMlsDisplayRulesEventRequest, MlsDisplayRulesService_StreamMlsDisplayRulesEventServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMlsDisplayRulesEvent not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) HealthCheck(context.Context, *HealthRequest) (*HealthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedMlsDisplayRulesServiceServer) mustEmbedUnimplementedMlsDisplayRulesServiceServer() {
}

// UnsafeMlsDisplayRulesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MlsDisplayRulesServiceServer will
// result in compilation errors.
type UnsafeMlsDisplayRulesServiceServer interface {
	mustEmbedUnimplementedMlsDisplayRulesServiceServer()
}

func RegisterMlsDisplayRulesServiceServer(s grpc.ServiceRegistrar, srv MlsDisplayRulesServiceServer) {
	s.RegisterService(&MlsDisplayRulesService_ServiceDesc, srv)
}

func _MlsDisplayRulesService_GetMlsDisplayRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMlsDisplayRulesByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRules(ctx, req.(*GetMlsDisplayRulesByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_GetMlsDisplayRulesIgnoreStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMlsDisplayRulesByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesIgnoreStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesIgnoreStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesIgnoreStatus(ctx, req.(*GetMlsDisplayRulesByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_GetMlsDisplayRulesBySource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMlsDisplayRulesBySourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesBySource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesBySource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesBySource(ctx, req.(*GetMlsDisplayRulesBySourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_GetMlsDisplayRulesBySourceIgnoreStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMlsDisplayRulesBySourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesBySourceIgnoreStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/GetMlsDisplayRulesBySourceIgnoreStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).GetMlsDisplayRulesBySourceIgnoreStatus(ctx, req.(*GetMlsDisplayRulesBySourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_UpdateMlsDisplayRulesStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMlsDisplayRulesStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).UpdateMlsDisplayRulesStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/UpdateMlsDisplayRulesStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).UpdateMlsDisplayRulesStatus(ctx, req.(*UpdateMlsDisplayRulesStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_UpdateMlsDisplayRulesData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMlsDisplayRulesDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).UpdateMlsDisplayRulesData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/UpdateMlsDisplayRulesData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).UpdateMlsDisplayRulesData(ctx, req.(*UpdateMlsDisplayRulesDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MlsDisplayRulesService_StreamMlsDisplayRules_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MlsDisplayRulesServiceServer).StreamMlsDisplayRules(m, &mlsDisplayRulesServiceStreamMlsDisplayRulesServer{stream})
}

type MlsDisplayRulesService_StreamMlsDisplayRulesServer interface {
	Send(*MlsDisplayRules) error
	grpc.ServerStream
}

type mlsDisplayRulesServiceStreamMlsDisplayRulesServer struct {
	grpc.ServerStream
}

func (x *mlsDisplayRulesServiceStreamMlsDisplayRulesServer) Send(m *MlsDisplayRules) error {
	return x.ServerStream.SendMsg(m)
}

func _MlsDisplayRulesService_StreamMlsDisplayRulesEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMlsDisplayRulesEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MlsDisplayRulesServiceServer).StreamMlsDisplayRulesEvent(m, &mlsDisplayRulesServiceStreamMlsDisplayRulesEventServer{stream})
}

type MlsDisplayRulesService_StreamMlsDisplayRulesEventServer interface {
	Send(*StreamMlsDisplayRulesEventResponse) error
	grpc.ServerStream
}

type mlsDisplayRulesServiceStreamMlsDisplayRulesEventServer struct {
	grpc.ServerStream
}

func (x *mlsDisplayRulesServiceStreamMlsDisplayRulesEventServer) Send(m *StreamMlsDisplayRulesEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MlsDisplayRulesService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MlsDisplayRulesServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/realogy.api.mls.displayrules.v1.MlsDisplayRulesService/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MlsDisplayRulesServiceServer).HealthCheck(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MlsDisplayRulesService_ServiceDesc is the grpc.ServiceDesc for MlsDisplayRulesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MlsDisplayRulesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "realogy.api.mls.displayrules.v1.MlsDisplayRulesService",
	HandlerType: (*MlsDisplayRulesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMlsDisplayRules",
			Handler:    _MlsDisplayRulesService_GetMlsDisplayRules_Handler,
		},
		{
			MethodName: "GetMlsDisplayRulesIgnoreStatus",
			Handler:    _MlsDisplayRulesService_GetMlsDisplayRulesIgnoreStatus_Handler,
		},
		{
			MethodName: "GetMlsDisplayRulesBySource",
			Handler:    _MlsDisplayRulesService_GetMlsDisplayRulesBySource_Handler,
		},
		{
			MethodName: "GetMlsDisplayRulesBySourceIgnoreStatus",
			Handler:    _MlsDisplayRulesService_GetMlsDisplayRulesBySourceIgnoreStatus_Handler,
		},
		{
			MethodName: "UpdateMlsDisplayRulesStatus",
			Handler:    _MlsDisplayRulesService_UpdateMlsDisplayRulesStatus_Handler,
		},
		{
			MethodName: "UpdateMlsDisplayRulesData",
			Handler:    _MlsDisplayRulesService_UpdateMlsDisplayRulesData_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _MlsDisplayRulesService_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMlsDisplayRules",
			Handler:       _MlsDisplayRulesService_StreamMlsDisplayRules_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMlsDisplayRulesEvent",
			Handler:       _MlsDisplayRulesService_StreamMlsDisplayRulesEvent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internal/proto/realogy/v1/mls_display_rules.proto",
}
